---
title: "Truffle Monitoring"
author: "Lia Baumann"
date: "2024-03-05"
output: github_document
bibliography: references.json
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Basis

The basis for the research about Truffle Monitoring data is described in detail in these publications:
@molinierFirstIdentificationPolymorphic2013
@molinierSSRbasedIdentificationGenetic2016
@molinierFinescaleGeneticStructure2016
@staubliHiddenFairyRings2022
@steidingerFallSummerTruffle2022
@legendreComparisonMantelTest2010
@kamvarPopprPackageGenetic2014


```{r Tabellen laden, message=FALSE, warning=FALSE, include=FALSE}
library(readxl)
library(knitr)
library(tidyverse)
library(ggplot2)
theme_set(theme_bw())
library(sf)
library(ggspatial)
library(rnaturalearth)
library(envalysis)
library(forcats)
library(poppr)
library(treemap)
library(pegas)
library(adegenet)
library(devtools)
library(hierfstat)
T_all <- read_excel("Tuaest_Master_genMonit_haploid_MP_2024.xlsx")
coord <- read_excel("Koordinaten_2024.xlsx")
```

## Monitoring Sites

```{r Maps laden, echo=FALSE, warning=FALSE}
europe <- ne_countries(scale="medium",returnclass="sf",continent="europe")
europe_points <- st_centroid(europe)
europe_points <- cbind(europe,st_coordinates(st_centroid(europe$geometry)))

ggplot(data=europe) + geom_sf() +
  geom_text(data=europe_points,aes(x=X,y=Y,label = name),
            color = "darkmagenta", fontface = "bold", check_overlap = FALSE) +
  annotation_scale(location = "bl", width_hint = 0.5) +
  #annotation_north_arrow(location = "bl",which_north = "true",
  #                       pad_x = unit(0.5,"in"),pad_y=unit(0.5,"in"),
  #                       style=north_arrow_fancy_orienteering) +
  coord_sf(xlim = c(5.5,11), ylim = c(45.5,48.5), expand = FALSE) +
  geom_point(data=coord,
             aes(x=LON, y=LAT),shape=20,color="darkcyan", fill = "darkcyan",
             pch = 5, size = 3)
```

The dataset was already corrected in the following way:
- Removal of samples with less than 10 markers
- Removal of samples with two mating types.


# Number of samples per Site

```{r erste Datensichtung, echo=FALSE}
# of observations per site
number_obs_all <- as.data.frame(T_all %>%
                                  count(Site_1_abrev))
coord_observ_table <- left_join(number_obs_all,coord,by="Site_1_abrev")
kable(select(coord_observ_table[,1:3 ],c(Site_1_abrev,Site,n)), caption = "Number of observations per site")
```

```{r Data structure per site, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(T_all, aes(x=Sampling_year)) +
  ylab("# of Samples") +
  xlab("Sampling year") +
  scale_x_discrete(limits=c(2010,2016,2021)) +
  geom_bar() +
  facet_wrap(vars(Site_1))
```

Evtl. später:
Standorte mit weniger als 10 Samples werden entfernt.
Dies lässt danach noch folgende Standorte für die Auswertung zu:

```{r Standorte mit weniger als 10 Samples entfernen, include=FALSE}
# of observations per site
T_all_corr1 <- subset(T_all,Site_1_abrev!="BAR")
T_all_corr2 <- subset(T_all_corr1, Site_1_abrev != "GEN")
```

#Idee: alle Observationen auf einer Zeitachse und nach Standort unterteilt anzeigen

```{r all observations, echo=FALSE, message=FALSE, warning=FALSE}

ggplot(T_all) +
  geom_point(aes(x=Sampling_date, y= fct_rev(Site_1_abrev), color = factor(Nb_markers))) +
  scale_colour_brewer(palette= "Greens") +
  theme_publish(base_family = "Times") +
  labs(title = "Overview of samples in truffle monitoring dataset",
       x = "Sampling year", y = "Sampling site abbreviation",
       colour = "Nb_markers")
```

##Clone correction
from https://grunwaldlab.github.io/Population_Genetics_in_R/Population_Strata.html
When dealing with clonal populations, analyses are typically conducted with and without clone correction. Clone correction is a method of censoring a data set such that only one individual per MLG is represented per population (Milgroom, 1996; Grünwald et al., 2003; Grünwald & Hoheisel, 2006). This technique is commonly used with the index of association and genotypic diversity measures since clone corrected populations approximate behavior of sexual populations. Since we want to only observe unique genotypes per population, clone correction requires specification of the stratifications at which clones should be censored. This section will show how to clone correct at a specific stratification and also compare the results with uncorrected data.

Question: Will allelic diversity increase or decrease with clone-censored data?

```{r load genalex data and first examinations, echo=FALSE}
myData_genind <- read.genalex("Daten_Genalex.csv",genclone=FALSE, ploidy=1, sep=";")
myData_genind
clonecorrect_data_genind <- clonecorrect(myData_genind)

barplot(table(pop(myData_genind)), col=funky(17), las=3,
xlab="Population", ylab="Sample size")

summary(myData_genind)
temp <- summary(myData_genind)
temp
barplot(myData_genind$loc.n.all,table(locNames(myData_genind)),col=funky(17),las=3,xlab="locNames",ylab="Number of alleles")
temp$Hexp
#plot(temp$Hexp, temp$Hobs, pch=20, cex=3, xlim=c(.4,1), ylim=c(.4,1))
abline(0,1,lty=2)
```


```{r first pca, echo=TRUE}
x.pops <- tab(myData_genind, freq=TRUE, NA.method="mean")
pca.pops <- dudi.pca(df = x.pops, center = TRUE, scale = FALSE, scannf = FALSE, nf = 2)

s.class(pca.pops$li, fac=pop(myData_genind), col=funky(15))

#clonecorrected PCA
x.pops_cc <- tab(clonecorrect_data_genind, freq=TRUE, NA.method="mean")
pca.pops_cc <- dudi.pca(df = x.pops_cc, center = TRUE, scale = FALSE, scannf = FALSE, nf = 2)
s.class(pca.pops_cc$li, fac=pop(clonecorrect_data_genind), col=funky(15))
```

```{r Fstat, eval=FALSE, include=FALSE}
library("hierfstat")
library(adegenet)
fstat(myData_genind)
gstat.randtest(myData_genind)
```

Show missing data

```{r missing data, eval=FALSE, include=FALSE}
info_table(myData,plot=TRUE)
#for more stuff (removal of individuals or loci etc.): grunwaldlab.github.io/population_genetics_in_r/locus_stats.html
```

Clone correction

```{r clone correction, eval=FALSE, include=FALSE}
clonecorrect_data <- clonecorrect(myData, strata=~Pop)
clonecorrect_data
genind2genalex(clonecorrect_data, filename="C:/Users/liaba/OneDrive - Eidg. Forschungsanstalt WSL/R/truffles/clonecorrected_data.csv")
```

```{r compare diversity between corrected and uncorrected, eval=FALSE, include=FALSE}
#see grunwaldlab.github.io/population_genetics_in_R/Population_Strata_html
cc <- locus_table(clonecorrect_data, info=FALSE)
mp <- locus_table(myData, info = FALSE)
mp-cc
locus_diff <- mp-cc
barplot(locus_diff[,"1-D"], ylab="Change in Simpson's Index",xlab="Locus", main = "Comparison of clone-corrected vs. uncorrected data")
```


The graph shows a decrease of diversity for most markers when clone-correcting the data (increase of Simpson index means a decrease of genotypic diversity).



Next step:
I want to compare genetic diversity across years and show it for populations. So I need to combine the sample and assign the sampling date.
I have several ideas how to do it.
1.
--> Join Genalex file with monitoring file on the sampling column.
--> then read it in as a genclone and genind file again.
2.
--> Filter monitoring file with genalex file to exclude the rows not matching
--> choose columns that I want to process as a new file and read in as genclone and genind file again.

```{r add dates into microsat file, eval=FALSE, include=FALSE}

##Achtung hier wird eine Tabelle generiert, nur bei Datenänderungen laufen lassen!!

genalex_dates <- read.csv("Daten_Genalex.csv",sep=";", header=FALSE)
T_all_dates <- T_all %>%
  mutate(Sampling_month = month(Sampling_date)) %>%
  select(Code_Analyses_2024,Sampling_month, Sampling_year)
genalex_dates <- left_join(genalex_dates,T_all_dates,by=c("V1"="Code_Analyses_2024"))

genalex_dates <- genalex_dates %>%
  unite(col="pop_date",c("V2","Sampling_month","Sampling_year"),sep="_")
#correct column names
genalex_dates$pop_date[genalex_dates$pop_date =="2708_NA_NA"] <- "2708"
genalex_dates$pop_date[genalex_dates$pop_date =="_NA_NA"] <- ""
genalex_dates$pop_date[genalex_dates$pop_date =="pop_NA_NA"] <- "pop"

#jetzt als csv Datei neu reinladen
#write.table(genalex_dates, col.names=FALSE, sep=",", "C:/Users/liaba/OneDrive - Eidg. Forschungsanstalt WSL/R/truffles/genalex_dates.csv")
```

```{r read in microsats_dates}
microsats_dates <- read.genalex("genalex_dates.csv",ploidy=1)
splitStrata(microsats_dates) <- ~Pop/Month/Year
microsats_dates
```

```{r treemap, echo=FALSE}
#treemap:
monstrata <- strata(microsats_dates) %>%     
  group_by(Pop,Month,Year) %>%
  summarize(Count = n())
monstrata
treemap(dtf = monstrata, index = nameStrata(microsats_dates), vSize = "Count",
        type = "categorical", vColor = "Pop", title = "Truffles")
```



## Genotype accumulation curve
A genotype accumulation curve is a tool that allows you to assess how much power you have to discriminate between unique individuals given a random sample of n loci. This analysis is particularly important for clonal organisms to confirm that a plateau has been reached in the number of loci necessary to discriminate individuals.
We specified sample = 1000 in our function call. This means that for each boxplot, n loci were randomly sampled 1000 times in order to create the distribution. Since this data has been curated, we can see that we have reached the plateau with 13 loci.
 
```{r genotype accumulation curve}
gac <- genotype_curve(microsats_dates, sample = 1000, quiet = TRUE)
```

We have anything between 5 and 24 alleles per locus. aest28_01 has the highest Simpson diversity (0.80) and aest10_1 as well as aest36_1 have the most evenly distributed alleles (0.88).
```{r allele frequencies, missing data, ploidy}
(microsats_lt <- locus_table(microsats_dates))
info_table(microsats_dates, type = "missing", plot = TRUE)
```


```{r set strata to Pop}
setPop(microsats_dates) <- ~Pop/Year
popdata <- poppr(microsats_dates)
popdata
#N = Number of individuals, MLG = Number of multilocus genotypes, eMLG = number of expected MLG at the smallest sample size >= 10 based on rarefaction
#SE = Standard error based on eMLG, H = Shannon-Wiener Index of MLG diversity
#G = Stoddart & Taylor's Index of MLG diversity
# lambda = Simpsons index, E.5 = Evenness, Hexp = Neis Expected Heterozygosity
#Ia = Index of association, rbarD = stand. Index of association
```

## Genotypic evenness

Evenness is a measure of the distribution of genotype abundances, wherein a population with equally abundant genotypes yields a value equal to 1 and a population dominated by a single genotype is closer to zero.

```{r genotypic evenness}
M.tab <- mlg.table(microsats_dates)
```

## Visualize diversity

Diversity measures incorporate both genotypic richness and abundance. There are three measures of genotypic diversity employed by poppr, the Shannon-Wiener index (H), Stoddart and Taylor’s index (G), and Simpson’s index (lambda). In our example, comparing the diversity of BB to FR shows that H is greater for FR (4.58 vs. 4.4), but G is lower (53.4 vs. 61.7). Thus, our expectation that diversity is lower for FR than BB is rejected in the case of H, which is likely due to the sensitivity of the Shannon-Wiener index to genotypic richness in the uneven sample sizes, and accepted in the case of G. To be fair, the sample size used to calculate these diversity measures is different and is therefore not an appropriate comparison.

For an easier statistic to grasp, we have included the Simpson index, which is simply one minus the sum of squared genotype frequencies. This measure provides an estimation of the probability that two randomly selected genotypes are different and scales from 0 (no genotypes are different) to 1 (all genotypes are different). In the data above, we can see that lambda is just barely higher in BB than FR (0.984 vs. 0.981). Since this might be an artifact of sample size, we can explore a correction of Simpson’s index for sample size by multiplying lambda by \(N/(N - 1)\). Since R is vectorized, we can do this for all of our populations at once:

```{r plot diversity Simpson}
popdata_pop_year <- separate(popdata,Pop,c("Pop","Year"))
ggplot(popdata_pop_year,aes(Year,lambda)) +
  geom_point() +
  facet_wrap(vars(Pop)) +
  theme_light() +
  labs(y="Simpson's index", title ="Simpson's index over the years")

#rarefied:
N      <- popdata_pop_year$N      # number of samples
lambda <- popdata_pop_year$lambda # Simpson's index
Simpson_rarefied <- (N/(N - 1)) * lambda              # Corrected Simpson's index

ggplot(popdata_pop_year,aes(Year,Simpson_rarefied)) +
  geom_point() +
  facet_wrap(vars(Pop)) +
  theme_light() +
  labs(y="Rarefied Simpson's index", title ="Rarefied Simpson's index over the years")
```
